
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Flask microframework &mdash; stutuz v0.1dev documentation</title>
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="stutuz v0.1dev documentation" href="index.html" />
    <link rel="next" title="Werkzeug WSGI utilities" href="werkzeug.html" />
    <link rel="prev" title="Hacking on stutuz" href="hacking.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="werkzeug.html" title="Werkzeug WSGI utilities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hacking.html" title="Hacking on stutuz"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">stutuz v0.1dev documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-flask">
<span id="flask-microframework"></span><h1>Flask microframework<a class="headerlink" href="#module-flask" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="http://flask.pocoo.org/docs/">Full documentation</a></li>
</ul>
<div class="section" id="application">
<h2>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Flask">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Flask</tt><big>(</big><em>import_name</em>, <em>static_path=None</em><big>)</big><a class="headerlink" href="#flask.Flask" title="Permalink to this definition">¶</a></dt>
<dd><p>The flask object implements a WSGI application and acts as the central
object.  It is passed the name of the module or package of the
application.  Once it is created it will act as a central registry for
the view functions, the URL rules, template configuration and much more.</p>
<p>The name of the package is used to resolve resources from inside the
package or the folder the module is contained in depending on if the
package parameter resolves to an actual python package (a folder with
an <cite>__init__.py</cite> file inside) or a standard module (just a <cite>.py</cite> file).</p>
<p>For more information about resource loading, see <tt class="xref py py-func docutils literal"><span class="pre">open_resource()</span></tt>.</p>
<p>Usually you create a <a class="reference internal" href="#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> instance in your main module or
in the <cite>__init__.py</cite> file of your package like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-about-the-first-parameter admonition ">
<p class="first admonition-title">About the First Parameter</p>
<p>The idea of the first parameter is to give Flask an idea what
belongs to your application.  This name is used to find resources
on the file system, can be used by extensions to improve debugging
information and a lot more.</p>
<p>So it&#8217;s important what you provide there.  If you are using a single
module, <cite>__name__</cite> is always the correct value.  If you however are
using a package, it&#8217;s usually recommended to hardcode the name of
your package there.</p>
<p>For example if your application is defined in <cite>yourapplication/app.py</cite>
you should create it with one of the two versions below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="s">&#39;yourapplication&#39;</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="last">Why is that?  The application will work even with <cite>__name__</cite>, thanks
to how resources are looked up.  However it will make debugging more
painful.  Certain extensions can make assumptions based on the
import name of your application.  For example the Flask-SQLAlchemy
extension will look for the code in your application that triggered
an SQL query in debug mode.  If the import name is not properly set
up, that debugging information is lost.  (For example it would only
pick up SQL queries in <cite>yourapplicaiton.app</cite> and not
<cite>yourapplication.views.frontend</cite>)</p>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.5: </span>The <cite>static_path</cite> parameter was added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>import_name</strong> &#8211; the name of the application package</li>
<li><strong>static_path</strong> &#8211; can be used to specify a different path for the
static files on the web.  Defaults to <tt class="docutils literal"><span class="pre">/static</span></tt>.
This does not affect the folder the files are served
<em>from</em>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flask.Flask.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>rule</em>, <em>endpoint=None</em>, <em>view_func=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.add_url_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a URL rule.  Works exactly like the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a>
decorator.  If a view_func is provided it will be registered with the
endpoint.</p>
<p>Basically this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Is equivalent to the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;index&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>If the view_func is not provided you will need to connect the endpoint
to a view function like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">view_functions</span><span class="p">[</span><span class="s">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.2: </span><cite>view_func</cite> parameter added.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.6: </span><cite>OPTIONS</cite> is added automatically as method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rule</strong> &#8211; the URL rule as string</li>
<li><strong>endpoint</strong> &#8211; the endpoint for the registered URL rule.  Flask
itself assumes the name of the view function as
endpoint</li>
<li><strong>view_func</strong> &#8211; the function to call when serving a request to the
provided endpoint</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/routing.html#werkzeug.routing.Rule" title="(in Werkzeug v0.7)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> object.  A change
to Werkzeug is handling of method options.  methods
is a list of methods this rule should be limited
to (<cite>GET</cite>, <cite>POST</cite> etc.).  By default a rule
just listens for <cite>GET</cite> (and implicitly <cite>HEAD</cite>).
Starting with Flask 0.6, <cite>OPTIONS</cite> is implicitly
added and handled by the standard request handling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.after_request">
<tt class="descname">after_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.after_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a function to be run after each request.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.after_request_funcs">
<tt class="descname">after_request_funcs</tt><a class="headerlink" href="#flask.Flask.after_request_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary with lists of functions that should be called after
each request.  The key of the dictionary is the name of the module
this function is active for, <cite>None</cite> for all requests.  This can for
example be used to open database connections or getting hold of the
currently logged in user.  To register a function here, use the
<a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.before_request">
<tt class="descname">before_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.before_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a function to run before each request.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.before_request_funcs">
<tt class="descname">before_request_funcs</tt><a class="headerlink" href="#flask.Flask.before_request_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary with lists of functions that should be called at the
beginning of the request.  The key of the dictionary is the name of
the module this function is active for, <cite>None</cite> for all requests.
This can for example be used to open database connections or
getting hold of the currently logged in user.  To register a
function here, use the <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.config">
<tt class="descname">config</tt><a class="headerlink" href="#flask.Flask.config" title="Permalink to this definition">¶</a></dt>
<dd><p>The configuration dictionary as <tt class="xref py py-class docutils literal"><span class="pre">Config</span></tt>.  This behaves
exactly like a regular dictionary but supports additional methods
to load a config from files.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.context_processor">
<tt class="descname">context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.context_processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a template context processor function.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.create_jinja_environment">
<tt class="descname">create_jinja_environment</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.create_jinja_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the Jinja2 environment based on <a class="reference internal" href="#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><tt class="xref py py-attr docutils literal"><span class="pre">jinja_options</span></tt></a>
and <a class="reference internal" href="#flask.Flask.select_jinja_autoescape" title="flask.Flask.select_jinja_autoescape"><tt class="xref py py-meth docutils literal"><span class="pre">select_jinja_autoescape()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5.</span></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.create_url_adapter">
<tt class="descname">create_url_adapter</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#flask.Flask.create_url_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a URL adapter for the given request.  The URL adapter
is created at a point where the request context is not yet set up
so the request is passed explicitly.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.debug">
<tt class="descname">debug</tt><a class="headerlink" href="#flask.Flask.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>The debug flag.  Set this to <cite>True</cite> to enable debugging of the
application.  In debug mode the debugger will kick in when an unhandled
exception ocurrs and the integrated server will automatically reload
the application if changes in the code are detected.</p>
<p>This attribute can also be configured from the config with the <cite>DEBUG</cite>
configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.debug_log_format">
<tt class="descname">debug_log_format</tt><a class="headerlink" href="#flask.Flask.debug_log_format" title="Permalink to this definition">¶</a></dt>
<dd><p>The logging format used for the debug logger.  This is only used when
the application is in debug mode, otherwise the attached logging
handler does the formatting.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.default_config">
<tt class="descname">default_config</tt><a class="headerlink" href="#flask.Flask.default_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Default configuration parameters.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.dispatch_request">
<tt class="descname">dispatch_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.dispatch_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the request dispatching.  Matches the URL and returns the
return value of the view or error handler.  This does not have to
be a response object.  In order to convert the return value to a
proper response object, call <a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.error_handlers">
<tt class="descname">error_handlers</tt><a class="headerlink" href="#flask.Flask.error_handlers" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of all registered error handlers.  The key is
be the error code as integer, the value the function that
should handle that error.
To register a error handler, use the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a>
decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.errorhandler">
<tt class="descname">errorhandler</tt><big>(</big><em>code</em><big>)</big><a class="headerlink" href="#flask.Flask.errorhandler" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that is used to register a function give a given
error code.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;This page does not exist&#39;</span><span class="p">,</span> <span class="mi">404</span>
</pre></div>
</div>
<p>You can also register a function as error handler without using
the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> decorator.  The following example is
equivalent to the one above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;This page does not exist&#39;</span><span class="p">,</span> <span class="mi">404</span>
<span class="n">app</span><span class="o">.</span><span class="n">error_handlers</span><span class="p">[</span><span class="mi">404</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_not_found</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>code</strong> &#8211; the code as integer for the handler</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_exception">
<tt class="descname">handle_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Default exception handling that kicks in when an exception
occours that is not catched.  In debug mode the exception will
be re-raised immediately, otherwise it is logged and the handler
for a 500 internal server error is used.  If no such handler
exists, a default 500 internal server error message is displayed.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_http_exception">
<tt class="descname">handle_http_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_http_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles an HTTP exception.  By default this will invoke the
registered error handlers and fall back to returning the
exception as response.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.init_jinja_globals">
<tt class="descname">init_jinja_globals</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.init_jinja_globals" title="Permalink to this definition">¶</a></dt>
<dd><p>Called directly after the environment was created to inject
some defaults (like <cite>url_for</cite>, <cite>get_flashed_messages</cite> and the
<cite>tojson</cite> filter.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_env">
<tt class="descname">jinja_env</tt><a class="headerlink" href="#flask.Flask.jinja_env" title="Permalink to this definition">¶</a></dt>
<dd><p>The Jinja2 environment.  It is created from the
<a class="reference internal" href="#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><tt class="xref py py-attr docutils literal"><span class="pre">jinja_options</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_options">
<tt class="descname">jinja_options</tt><a class="headerlink" href="#flask.Flask.jinja_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Options that are passed directly to the Jinja2 environment.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.logger">
<tt class="descname">logger</tt><a class="headerlink" href="#flask.Flask.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">logging.Logger</span></tt> object for this application.  The
default configuration is to log to stderr if the application is
in debug mode.  This logger can be used to (surprise) log messages.
Here some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;A warning ocurred (</span><span class="si">%d</span><span class="s"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;An error occoured&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.logger_name">
<tt class="descname">logger_name</tt><a class="headerlink" href="#flask.Flask.logger_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the logger to use.  By default the logger name is the
package name passed to the constructor.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.</span></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.make_response">
<tt class="descname">make_response</tt><big>(</big><em>rv</em><big>)</big><a class="headerlink" href="#flask.Flask.make_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the return value from a view function to a real
response object that is an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a>.</p>
<p>The following types are allowed for <cite>rv</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a></td>
<td>the object is returned unchanged</td>
</tr>
<tr><td><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></td>
<td>a response object is created with the
string as body</td>
</tr>
<tr><td><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></td>
<td>a response object is created with the
string encoded to utf-8 as body</td>
</tr>
<tr><td><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></td>
<td>the response object is created with the
contents of the tuple as arguments</td>
</tr>
<tr><td>a WSGI function</td>
<td>the function is called as WSGI application
and buffered as response object</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rv</strong> &#8211; the return value from the view function</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.modules">
<tt class="descname">modules</tt><a class="headerlink" href="#flask.Flask.modules" title="Permalink to this definition">¶</a></dt>
<dd><p>all the loaded modules in a dictionary by name.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5.</span></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.open_session">
<tt class="descname">open_session</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#flask.Flask.open_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates or opens a new session.  Default implementation stores all
session data in a signed cookie.  This requires that the
<a class="reference internal" href="#flask.Flask.secret_key" title="flask.Flask.secret_key"><tt class="xref py py-attr docutils literal"><span class="pre">secret_key</span></tt></a> is set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>request</strong> &#8211; an instance of <a class="reference internal" href="#flask.Flask.request_class" title="flask.Flask.request_class"><tt class="xref py py-attr docutils literal"><span class="pre">request_class</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.permanent_session_lifetime">
<tt class="descname">permanent_session_lifetime</tt><a class="headerlink" href="#flask.Flask.permanent_session_lifetime" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/library/datetime.html#datetime.timedelta" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">timedelta</span></tt></a> which is used to set the expiration
date of a permanent session.  The default is 31 days which makes a
permanent session survive for roughly one month.</p>
<p>This attribute can also be configured from the config with the
<cite>PERMANENT_SESSION_LIFETIME</cite> configuration key.  Defaults to
<tt class="docutils literal"><span class="pre">timedelta(days=31)</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.preprocess_request">
<tt class="descname">preprocess_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.preprocess_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before the actual request dispatching and will
call every as <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorated function.
If any of these function returns a value it&#8217;s handled as
if it was the return value from the view and further
request handling is stopped.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.process_response">
<tt class="descname">process_response</tt><big>(</big><em>response</em><big>)</big><a class="headerlink" href="#flask.Flask.process_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Can be overridden in order to modify the response object
before it&#8217;s sent to the WSGI server.  By default this will
call all the <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> decorated functions.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.5: </span>As of Flask 0.5 the functions registered for after request
execution are called in reverse order of registration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>response</strong> &#8211; a <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> object.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new response object or the same, has to be an
instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.register_module">
<tt class="descname">register_module</tt><big>(</big><em>module</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.register_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a module with this application.  The keyword argument
of this function are the same as the ones for the constructor of the
<a class="reference internal" href="#flask.Module" title="flask.Module"><tt class="xref py py-class docutils literal"><span class="pre">Module</span></tt></a> class and will override the values of the module if
provided.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.request_class">
<tt class="descname">request_class</tt><a class="headerlink" href="#flask.Flask.request_class" title="Permalink to this definition">¶</a></dt>
<dd><p>The class that is used for request objects.  See <a class="reference internal" href="#flask.Request" title="flask.Request"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a>
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.request_context">
<tt class="descname">request_context</tt><big>(</big><em>environ</em><big>)</big><a class="headerlink" href="#flask.Flask.request_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a request context from the given environment and binds
it to the current context.  This must be used in combination with
the <cite>with</cite> statement because the request is only bound to the
current context for the duration of the <cite>with</cite> block.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</div>
<p>The object returned can also be used without the <cite>with</cite> statement
which is useful for working in the shell.  The example above is
doing exactly the same as this code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>The big advantage of this approach is that you can use it without
the try/finally statement in a shell for interactive testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">bind</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">path</span>
<span class="go">u&#39;/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">unbind</span><span class="p">()</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.3: </span>Added support for non-with statement usage and <cite>with</cite> statement
is now passed the ctx object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>environ</strong> &#8211; a WSGI environment</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.response_class">
<tt class="descname">response_class</tt><a class="headerlink" href="#flask.Flask.response_class" title="Permalink to this definition">¶</a></dt>
<dd><p>The class that is used for response objects.  See
<a class="reference internal" href="#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> for more information.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.route">
<tt class="descname">route</tt><big>(</big><em>rule</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.route" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that is used to register a view function for a
given URL rule.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>Variables parts in the route can be specified with angular
brackets (<tt class="docutils literal"><span class="pre">/user/&lt;username&gt;</span></tt>).  By default a variable part
in the URL accepts any string without a slash however a different
converter can be specified as well by using <tt class="docutils literal"><span class="pre">&lt;converter:name&gt;</span></tt>.</p>
<p>Variable parts are passed to the view function as keyword
arguments.</p>
<p>The following converters are possible:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr><td><cite>int</cite></td>
<td>accepts integers</td>
</tr>
<tr><td><cite>float</cite></td>
<td>like <cite>int</cite> but for floating point values</td>
</tr>
<tr><td><cite>path</cite></td>
<td>like the default but also accepts slashes</td>
</tr>
</tbody>
</table>
<p>Here some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>An important detail to keep in mind is how Flask deals with trailing
slashes.  The idea is to keep each URL unique so the following rules
apply:</p>
<ol class="arabic simple">
<li>If a rule ends with a slash and is requested without a slash
by the user, the user is automatically redirected to the same
page with a trailing slash attached.</li>
<li>If a rule does not end with a trailing slash and the user request
the page with a trailing slash, a 404 not found is raised.</li>
</ol>
<p>This is consistent with how web servers deal with static files.  This
also makes it possible to use relative link targets safely.</p>
<p>The <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> decorator accepts a couple of other arguments
as well:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rule</strong> &#8211; the URL rule as string</li>
<li><strong>methods</strong> &#8211; a list of methods this rule should be limited
to (<cite>GET</cite>, <cite>POST</cite> etc.).  By default a rule
just listens for <cite>GET</cite> (and implicitly <cite>HEAD</cite>).
Starting with Flask 0.6, <cite>OPTIONS</cite> is implicitly
added and handled by the standard request handling.</li>
<li><strong>subdomain</strong> &#8211; specifies the rule for the subdomain in case
subdomain matching is in use.</li>
<li><strong>strict_slashes</strong> &#8211; can be used to disable the strict slashes
setting for this rule.  See above.</li>
<li><strong>options</strong> &#8211; other options to be forwarded to the underlying
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/routing.html#werkzeug.routing.Rule" title="(in Werkzeug v0.7)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.run">
<tt class="descname">run</tt><big>(</big><em>host='127.0.0.1'</em>, <em>port=5000</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the application on a local development server.  If the
<a class="reference internal" href="#flask.Flask.debug" title="flask.Flask.debug"><tt class="xref py py-attr docutils literal"><span class="pre">debug</span></tt></a> flag is set the server will automatically reload
for code changes and show a debugger in case an exception happened.</p>
<p>If you want to run the application in debug mode, but disable the
code execution on the interactive debugger, you can pass
<tt class="docutils literal"><span class="pre">use_evalex=False</span></tt> as parameter.  This will keep the debugger&#8217;s
traceback screen active, but disable code execution.</p>
<div class="admonition-keep-in-mind admonition ">
<p class="first admonition-title">Keep in Mind</p>
<p class="last">Flask will suppress any server error with a generic error page
unless it is in debug mode.  As such to enable just the
interactive debugger without the code reloading, you have to
invoke <a class="reference internal" href="#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> with <tt class="docutils literal"><span class="pre">debug=True</span></tt> and <tt class="docutils literal"><span class="pre">use_reloader=False</span></tt>.
Setting <tt class="docutils literal"><span class="pre">use_debugger</span></tt> to <cite>True</cite> without being in debug mode
won&#8217;t catch any exceptions because there won&#8217;t be any to
catch.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>host</strong> &#8211; the hostname to listen on.  set this to <tt class="docutils literal"><span class="pre">'0.0.0.0'</span></tt>
to have the server available externally as well.</li>
<li><strong>port</strong> &#8211; the port of the webserver</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
Werkzeug server.  See <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/serving.html#werkzeug.run_simple" title="(in Werkzeug v0.7)"><tt class="xref py py-func docutils literal"><span class="pre">werkzeug.run_simple()</span></tt></a>
for more information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.save_session">
<tt class="descname">save_session</tt><big>(</big><em>session</em>, <em>response</em><big>)</big><a class="headerlink" href="#flask.Flask.save_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the session if it needs updates.  For the default
implementation, check <a class="reference internal" href="#flask.Flask.open_session" title="flask.Flask.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>session</strong> &#8211; the session to be saved (a
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/contrib/securecookie.html#werkzeug.contrib.securecookie.SecureCookie" title="(in Werkzeug v0.7)"><tt class="xref py py-class docutils literal"><span class="pre">SecureCookie</span></tt></a>
object)</li>
<li><strong>response</strong> &#8211; an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.secret_key">
<tt class="descname">secret_key</tt><a class="headerlink" href="#flask.Flask.secret_key" title="Permalink to this definition">¶</a></dt>
<dd><p>If a secret key is set, cryptographic components can use this to
sign cookies and other things.  Set this to a complex random value
when you want to use the secure cookie for instance.</p>
<p>This attribute can also be configured from the config with the
<cite>SECRET_KEY</cite> configuration key.  Defaults to <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.select_jinja_autoescape">
<tt class="descname">select_jinja_autoescape</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Flask.select_jinja_autoescape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>True</cite> if autoescaping should be active for the given
template name.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.session_cookie_name">
<tt class="descname">session_cookie_name</tt><a class="headerlink" href="#flask.Flask.session_cookie_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The secure cookie uses this for the name of the session cookie.</p>
<p>This attribute can also be configured from the config with the
<cite>SESSION_COOKIE_NAME</cite> configuration key.  Defaults to <tt class="docutils literal"><span class="pre">'session'</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.static_path">
<tt class="descname">static_path</tt><a class="headerlink" href="#flask.Flask.static_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Path for the static files.  If you don&#8217;t want to use static files
you can set this value to <cite>None</cite> in which case no URL rule is added
and the development server will no longer serve any static files.</p>
<p>This is the default used for application and modules unless a
different value is passed to the constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.template_context_processors">
<tt class="descname">template_context_processors</tt><a class="headerlink" href="#flask.Flask.template_context_processors" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary with list of functions that are called without argument
to populate the template context.  They key of the dictionary is the
name of the module this function is active for, <cite>None</cite> for all
requests.  Each returns a dictionary that the template context is
updated with.  To register a function here, use the
<a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">context_processor()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.template_filter">
<tt class="descname">template_filter</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#flask.Flask.template_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that is used to register custom template filter.
You can specify a name for the filter, otherwise the function
name will be used. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.template_filter</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; the optional name of the filter, otherwise the
function name will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.test_client">
<tt class="descname">test_client</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.test_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a test client for this application.  For information
about unit testing head over to <a class="reference external" href="http://flask.pocoo.org/docs/testing/#testing" title="(in Flask v0.6)"><em>Testing Flask Applications</em></a>.</p>
<p>The test client can be used in a <cite>with</cite> block to defer the closing down
of the context until the end of the <cite>with</cite> block.  This is useful if
you want to access the context locals for testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/?vodka=42&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;vodka&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;42&#39;</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.4: </span>added support for <cite>with</cite> block usage for the client.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.test_request_context">
<tt class="descname">test_request_context</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.test_request_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a WSGI environment from the given values (see
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/test.html#werkzeug.create_environ" title="(in Werkzeug v0.7)"><tt class="xref py py-func docutils literal"><span class="pre">werkzeug.create_environ()</span></tt></a> for more information, this
function accepts the same arguments).</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.testing">
<tt class="descname">testing</tt><a class="headerlink" href="#flask.Flask.testing" title="Permalink to this definition">¶</a></dt>
<dd><p>The testing flask.  Set this to <cite>True</cite> to enable the test mode of
Flask extensions (and in the future probably also Flask itself).
For example this might activate unittest helpers that have an
additional runtime cost which should not be enabled by default.</p>
<p>This attribute can also be configured from the config with the
<cite>TESTING</cite> configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.update_template_context">
<tt class="descname">update_template_context</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#flask.Flask.update_template_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the template context with some commonly used variables.
This injects request, session, config and g into the template
context as well as everything template context processors want
to inject.  Note that the as of Flask 0.6, the original values
in the context will not be overriden if a context processor
decides to return a value with the same key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> &#8211; the context as a dictionary that is updated in place
to add extra variables.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_map">
<tt class="descname">url_map</tt><a class="headerlink" href="#flask.Flask.url_map" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/routing.html#werkzeug.routing.Map" title="(in Werkzeug v0.7)"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> for this instance.  You can use
this to change the routing converters after the class was created
but before any routes are connected.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">BaseConverter</span>

<span class="k">class</span> <span class="nc">ListConverter</span><span class="p">(</span><span class="n">BaseConverter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseConverter</span><span class="o">.</span><span class="n">to_url</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">url_map</span><span class="o">.</span><span class="n">converters</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ListConverter</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.use_x_sendfile">
<tt class="descname">use_x_sendfile</tt><a class="headerlink" href="#flask.Flask.use_x_sendfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable this if you want to use the X-Sendfile feature.  Keep in
mind that the server has to support this.  This only affects files
sent with the <a class="reference internal" href="#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> method.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
<p>This attribute can also be configured from the config with the
<cite>USE_X_SENDFILE</cite> configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.view_functions">
<tt class="descname">view_functions</tt><a class="headerlink" href="#flask.Flask.view_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of all view functions registered.  The keys will
be function names which are also used to generate URLs and
the values are the function objects themselves.
to register a view function, use the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> decorator.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.wsgi_app">
<tt class="descname">wsgi_app</tt><big>(</big><em>environ</em>, <em>start_response</em><big>)</big><a class="headerlink" href="#flask.Flask.wsgi_app" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual WSGI application.  This is not implemented in
<cite>__call__</cite> so that middlewares can be applied without losing a
reference to the class.  So instead of doing this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s a better idea to do this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you still have the original application object around and
can continue to call methods on it.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.4: </span>The <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> functions are now called even if an
error handler took over request processing.  This ensures that
even if an exception happens database have the chance to
properly close the connection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>environ</strong> &#8211; a WSGI environment</li>
<li><strong>start_response</strong> &#8211; a callable accepting a status code,
a list of headers and an optional
exception context to start the response</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.Module">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Module</tt><big>(</big><em>import_name</em>, <em>name=None</em>, <em>url_prefix=None</em>, <em>static_path=None</em>, <em>subdomain=None</em><big>)</big><a class="headerlink" href="#flask.Module" title="Permalink to this definition">¶</a></dt>
<dd><p>Container object that enables pluggable applications.  A module can
be used to organize larger applications.  They represent blueprints that,
in combination with a <a class="reference internal" href="#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> object are used to create a large
application.</p>
<p>A module is like an application bound to an <cite>import_name</cite>.  Multiple
modules can share the same import names, but in that case a <cite>name</cite> has
to be provided to keep them apart.  If different import names are used,
the rightmost part of the import name is used as name.</p>
<p>Here an example structure for a larger appliation:</p>
<div class="highlight-python"><pre>/myapplication
    /__init__.py
    /views
        /__init__.py
        /admin.py
        /frontend.py</pre>
</div>
<p>The <cite>myapplication/__init__.py</cite> can look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">myapplication.views.admin</span> <span class="kn">import</span> <span class="n">admin</span>
<span class="kn">from</span> <span class="nn">myapplication.views.frontend</span> <span class="kn">import</span> <span class="n">frontend</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_module</span><span class="p">(</span><span class="n">admin</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">&#39;/admin&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_module</span><span class="p">(</span><span class="n">frontend</span><span class="p">)</span>
</pre></div>
</div>
<p>And here an example view module (<cite>myapplication/views/admin.py</cite>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Module</span>

<span class="n">admin</span> <span class="o">=</span> <span class="n">Module</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@admin.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@admin.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>For a gentle introduction into modules, checkout the
<a class="reference external" href="http://flask.pocoo.org/docs/patterns/packages/#working-with-modules" title="(in Flask v0.6)"><em>Working with Modules</em></a> section.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5: </span>The <cite>static_path</cite> parameter was added and it&#8217;s now possible for
modules to refer to their own templates and static files.  See
<a class="reference external" href="http://flask.pocoo.org/docs/patterns/packages/#modules-and-resources" title="(in Flask v0.6)"><em>Modules and Resources</em></a> for more information.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6: </span>The <cite>subdomain</cite> parameter was added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>import_name</strong> &#8211; the name of the Python package or module
implementing this <a class="reference internal" href="#flask.Module" title="flask.Module"><tt class="xref py py-class docutils literal"><span class="pre">Module</span></tt></a>.</li>
<li><strong>name</strong> &#8211; the internal short name for the module.  Unless specified
the rightmost part of the import name</li>
<li><strong>url_prefix</strong> &#8211; an optional string that is used to prefix all the
URL rules of this module.  This can also be specified
when registering the module with the application.</li>
<li><strong>subdomain</strong> &#8211; used to set the subdomain setting for URL rules that
do not have a subdomain setting set.</li>
<li><strong>static_path</strong> &#8211; can be used to specify a different path for the
static files on the web.  Defaults to <tt class="docutils literal"><span class="pre">/static</span></tt>.
This does not affect the folder the files are served
<em>from</em>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flask.Module.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>rule</em>, <em>endpoint=None</em>, <em>view_func=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Module.add_url_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.add_url_rule()</span></tt></a> but for a module.  The endpoint for
the <a class="reference internal" href="#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> function is prefixed with the name of the module.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.6: </span>The <cite>endpoint</cite> argument is now optional and will default to the
function name to consistent with the function of the same name
on the application object.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.after_app_request">
<tt class="descname">after_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.after_app_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.after_request()</span></tt></a> but for a module.  Such a function
is executed after each request, even if outside of the module.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.after_request">
<tt class="descname">after_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.after_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.after_request()</span></tt></a> but for a module.  This function
is only executed after each request that is handled by a function of
that module.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.app_context_processor">
<tt class="descname">app_context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.app_context_processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.context_processor()</span></tt></a> but for a module.  Such a
function is executed each request, even if outside of the module.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.app_errorhandler">
<tt class="descname">app_errorhandler</tt><big>(</big><em>code</em><big>)</big><a class="headerlink" href="#flask.Module.app_errorhandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.errorhandler()</span></tt></a> but for a module.  This
handler is used for all requests, even if outside of the module.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.</span></p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.before_app_request">
<tt class="descname">before_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.before_app_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_request()</span></tt></a>.  Such a function is executed
before each request, even if outside of a module.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.before_request">
<tt class="descname">before_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.before_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_request()</span></tt></a> but for a module.  This function
is only executed before each request that is handled by a function of
that module.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.context_processor">
<tt class="descname">context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.context_processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.context_processor()</span></tt></a> but for a module.  This
function is only executed for requests handled by a module.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Module.route">
<tt class="descname">route</tt><big>(</big><em>rule</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Module.route" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.route()</span></tt></a> but for a module.  The endpoint for the
<a class="reference internal" href="#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> function is prefixed with the name of the module.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="request-and-response">
<h2>Request and Response<a class="headerlink" href="#request-and-response" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Request">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Request</tt><big>(</big><em>environ</em>, <em>populate_request=True</em>, <em>shallow=False</em><big>)</big><a class="headerlink" href="#flask.Request" title="Permalink to this definition">¶</a></dt>
<dd><p>The request object used by default in flask.  Remembers the
matched endpoint and view arguments.</p>
<p>It is what ends up as <a class="reference external" href="http://flask.pocoo.org/docs/api/#flask.request" title="(in Flask v0.6)"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a>.  If you want to replace
the request object used you can subclass this and set
<a class="reference internal" href="#flask.Flask.request_class" title="flask.Flask.request_class"><tt class="xref py py-attr docutils literal"><span class="pre">request_class</span></tt></a> to your subclass.</p>
<dl class="attribute">
<dt id="flask.Request.accept_charsets">
<tt class="descname">accept_charsets</tt><a class="headerlink" href="#flask.Request.accept_charsets" title="Permalink to this definition">¶</a></dt>
<dd><p>List of charsets this client supports as <tt class="xref py py-class docutils literal"><span class="pre">CharsetAccept</span></tt>
object.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.accept_encodings">
<tt class="descname">accept_encodings</tt><a class="headerlink" href="#flask.Request.accept_encodings" title="Permalink to this definition">¶</a></dt>
<dd><p>List of encodings this client accepts.  Encodings in a HTTP term
are compression encodings such as gzip.  For charsets have a look at
<tt class="xref py py-attr docutils literal"><span class="pre">accept_charset</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.accept_languages">
<tt class="descname">accept_languages</tt><a class="headerlink" href="#flask.Request.accept_languages" title="Permalink to this definition">¶</a></dt>
<dd><p>List of languages this client accepts as <tt class="xref py py-class docutils literal"><span class="pre">LanguageAccept</span></tt>
object.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.accept_mimetypes">
<tt class="descname">accept_mimetypes</tt><a class="headerlink" href="#flask.Request.accept_mimetypes" title="Permalink to this definition">¶</a></dt>
<dd><p>List of mimetypes this client supports as <tt class="xref py py-class docutils literal"><span class="pre">MIMEAccept</span></tt>
object.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.access_route">
<tt class="descname">access_route</tt><a class="headerlink" href="#flask.Request.access_route" title="Permalink to this definition">¶</a></dt>
<dd><p>If a forwarded header exists this is a list of all ip addresses
from the client ip to the last proxy server.</p>
</dd></dl>

<dl class="classmethod">
<dt id="flask.Request.application">
<em class="property">classmethod </em><tt class="descname">application</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Request.application" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate a function as responder that accepts the request as first
argument.  This works like the <tt class="xref py py-func docutils literal"><span class="pre">responder()</span></tt> decorator but the
function is passed the request object as first argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@Request.application</span>
<span class="k">def</span> <span class="nf">my_wsgi_app</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Hello World!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> &#8211; the WSGI callable to decorate</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new WSGI callable</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.args">
<tt class="descname">args</tt><a class="headerlink" href="#flask.Request.args" title="Permalink to this definition">¶</a></dt>
<dd><p>The parsed URL parameters.  By default a <tt class="xref py py-class docutils literal"><span class="pre">ImmutableMultiDict</span></tt>
is returned from this function.  This can be changed by setting
<a class="reference internal" href="#flask.Request.parameter_storage_class" title="flask.Request.parameter_storage_class"><tt class="xref py py-attr docutils literal"><span class="pre">parameter_storage_class</span></tt></a> to a different type.  This might
be necessary if the order of the form data is important.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.authorization">
<tt class="descname">authorization</tt><a class="headerlink" href="#flask.Request.authorization" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>Authorization</cite> object in parsed form.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.base_url">
<tt class="descname">base_url</tt><a class="headerlink" href="#flask.Request.base_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Request.url" title="flask.Request.url"><tt class="xref py py-attr docutils literal"><span class="pre">url</span></tt></a> but without the querystring</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.cache_control">
<tt class="descname">cache_control</tt><a class="headerlink" href="#flask.Request.cache_control" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">RequestCacheControl</span></tt> object for the incoming cache control
headers.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.content_length">
<tt class="descname">content_length</tt><a class="headerlink" href="#flask.Request.content_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Length entity-header field indicates the size of the
entity-body in bytes or, in the case of the HEAD method, the size of
the entity-body that would have been sent had the request been a
GET.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.content_type">
<tt class="descname">content_type</tt><a class="headerlink" href="#flask.Request.content_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Type entity-header field indicates the media type of
the entity-body sent to the recipient or, in the case of the HEAD
method, the media type that would have been sent had the request
been a GET.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.cookies">
<tt class="descname">cookies</tt><a class="headerlink" href="#flask.Request.cookies" title="Permalink to this definition">¶</a></dt>
<dd><p>Read only access to the retrieved cookie values as dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.data">
<tt class="descname">data</tt><a class="headerlink" href="#flask.Request.data" title="Permalink to this definition">¶</a></dt>
<dd><p>This reads the buffered incoming data from the client into the
string.  Usually it&#8217;s a bad idea to access <a class="reference internal" href="#flask.Request.data" title="flask.Request.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a> because a client
could send dozens of megabytes or more to cause memory problems on the
server.</p>
<p>To circumvent that make sure to check the content length first.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.date">
<tt class="descname">date</tt><a class="headerlink" href="#flask.Request.date" title="Permalink to this definition">¶</a></dt>
<dd><p>The Date general-header field represents the date and time at which
the message was originated, having the same semantics as orig-date
in RFC 822.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.dict_storage_class">
<tt class="descname">dict_storage_class</tt><a class="headerlink" href="#flask.Request.dict_storage_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">ImmutableTypeConversionDict</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.endpoint">
<tt class="descname">endpoint</tt><a class="headerlink" href="#flask.Request.endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The endpoint that matched the request.  This in combination with
<a class="reference internal" href="#flask.Request.view_args" title="flask.Request.view_args"><tt class="xref py py-attr docutils literal"><span class="pre">view_args</span></tt></a> can be used to reconstruct the same or a
modified URL.  If an exception happened when matching, this will
be <cite>None</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.files">
<tt class="descname">files</tt><a class="headerlink" href="#flask.Request.files" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt> object containing all uploaded files.  Each key in
<a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt></a> is the name from the <tt class="docutils literal"><span class="pre">&lt;input</span> <span class="pre">type=&quot;file&quot;</span> <span class="pre">name=&quot;&quot;&gt;</span></tt>.  Each
value in <a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt></a> is a Werkzeug <tt class="xref py py-class docutils literal"><span class="pre">FileStorage</span></tt> object.</p>
<p>Note that <a class="reference internal" href="#flask.Request.files" title="flask.Request.files"><tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt></a> will only contain data if the request method was
POST or PUT and the <tt class="docutils literal"><span class="pre">&lt;form&gt;</span></tt> that posted to the request had
<tt class="docutils literal"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></tt>.  It will be empty otherwise.</p>
<p>See the <tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt> / <tt class="xref py py-class docutils literal"><span class="pre">FileStorage</span></tt> documentation for more
details about the used data structure.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.form">
<tt class="descname">form</tt><a class="headerlink" href="#flask.Request.form" title="Permalink to this definition">¶</a></dt>
<dd><p>The form parameters.  By default a <tt class="xref py py-class docutils literal"><span class="pre">ImmutableMultiDict</span></tt>
is returned from this function.  This can be changed by setting
<a class="reference internal" href="#flask.Request.parameter_storage_class" title="flask.Request.parameter_storage_class"><tt class="xref py py-attr docutils literal"><span class="pre">parameter_storage_class</span></tt></a> to a different type.  This might
be necessary if the order of the form data is important.</p>
</dd></dl>

<dl class="classmethod">
<dt id="flask.Request.from_values">
<em class="property">classmethod </em><tt class="descname">from_values</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Request.from_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new request object based on the values provided.  If
environ is given missing values are filled from there.  This method is
useful for small scripts when you need to simulate a request from an URL.
Do not use this method for unittesting, there is a full featured client
object (<tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt>) that allows to create multipart requests,
support for cookies etc.</p>
<p>This accepts the same options as the <tt class="xref py py-class docutils literal"><span class="pre">EnvironBuilder</span></tt>.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.5: </span>This method now accepts the same arguments as
<tt class="xref py py-class docutils literal"><span class="pre">EnvironBuilder</span></tt>.  Because of this the <cite>environ</cite> parameter
is now called <cite>environ_overrides</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">request object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.headers">
<tt class="descname">headers</tt><a class="headerlink" href="#flask.Request.headers" title="Permalink to this definition">¶</a></dt>
<dd><p>The headers from the WSGI environ as immutable
<tt class="xref py py-class docutils literal"><span class="pre">EnvironHeaders</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.host">
<tt class="descname">host</tt><a class="headerlink" href="#flask.Request.host" title="Permalink to this definition">¶</a></dt>
<dd><p>Just the host including the port if available.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.host_url">
<tt class="descname">host_url</tt><a class="headerlink" href="#flask.Request.host_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Just the host with scheme.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.if_match">
<tt class="descname">if_match</tt><a class="headerlink" href="#flask.Request.if_match" title="Permalink to this definition">¶</a></dt>
<dd><p>An object containing all the etags in the <cite>If-Match</cite> header.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.if_modified_since">
<tt class="descname">if_modified_since</tt><a class="headerlink" href="#flask.Request.if_modified_since" title="Permalink to this definition">¶</a></dt>
<dd><p>The parsed <cite>If-Modified-Since</cite> header as datetime object.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.if_none_match">
<tt class="descname">if_none_match</tt><a class="headerlink" href="#flask.Request.if_none_match" title="Permalink to this definition">¶</a></dt>
<dd><p>An object containing all the etags in the <cite>If-None-Match</cite> header.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.if_unmodified_since">
<tt class="descname">if_unmodified_since</tt><a class="headerlink" href="#flask.Request.if_unmodified_since" title="Permalink to this definition">¶</a></dt>
<dd><p>The parsed <cite>If-Unmodified-Since</cite> header as datetime object.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.is_multiprocess">
<tt class="descname">is_multiprocess</tt><a class="headerlink" href="#flask.Request.is_multiprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean that is <cite>True</cite> if the application is served by
a WSGI server that spawns multiple processes.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.is_multithread">
<tt class="descname">is_multithread</tt><a class="headerlink" href="#flask.Request.is_multithread" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean that is <cite>True</cite> if the application is served by
a multithreaded WSGI server.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.is_run_once">
<tt class="descname">is_run_once</tt><a class="headerlink" href="#flask.Request.is_run_once" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean that is <cite>True</cite> if the application will be executed only
once in a process lifetime.  This is the case for CGI for example,
but it&#8217;s not guaranteed that the exeuction only happens one time.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.is_secure">
<tt class="descname">is_secure</tt><a class="headerlink" href="#flask.Request.is_secure" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> if the request is secure.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.is_xhr">
<tt class="descname">is_xhr</tt><a class="headerlink" href="#flask.Request.is_xhr" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the request was triggered via a JavaScript XMLHttpRequest.
This only works with libraries that support the <cite>X-Requested-With</cite>
header and set it to &#8220;XMLHttpRequest&#8221;.  Libraries that do that are
prototype, jQuery and Mochikit and probably some more.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.json">
<tt class="descname">json</tt><a class="headerlink" href="#flask.Request.json" title="Permalink to this definition">¶</a></dt>
<dd><p>If the mimetype is <cite>application/json</cite> this will contain the
parsed JSON data.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.list_storage_class">
<tt class="descname">list_storage_class</tt><a class="headerlink" href="#flask.Request.list_storage_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">ImmutableList</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.max_content_length">
<tt class="descname">max_content_length</tt><a class="headerlink" href="#flask.Request.max_content_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only view of the <cite>MAX_CONTENT_LENGTH</cite> config key.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.max_forwards">
<tt class="descname">max_forwards</tt><a class="headerlink" href="#flask.Request.max_forwards" title="Permalink to this definition">¶</a></dt>
<dd><p>The Max-Forwards request-header field provides a mechanism with the
TRACE and OPTIONS methods to limit the number of proxies or gateways
that can forward the request to the next inbound server.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.method">
<tt class="descname">method</tt><a class="headerlink" href="#flask.Request.method" title="Permalink to this definition">¶</a></dt>
<dd><p>The transmission method. (For example <tt class="docutils literal"><span class="pre">'GET'</span></tt> or <tt class="docutils literal"><span class="pre">'POST'</span></tt>).</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.mimetype">
<tt class="descname">mimetype</tt><a class="headerlink" href="#flask.Request.mimetype" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#flask.Request.content_type" title="flask.Request.content_type"><tt class="xref py py-attr docutils literal"><span class="pre">content_type</span></tt></a> but without parameters (eg, without
charset, type etc.).  For example if the content
type is <tt class="docutils literal"><span class="pre">text/html;</span> <span class="pre">charset=utf-8</span></tt> the mimetype would be
<tt class="docutils literal"><span class="pre">'text/html'</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.mimetype_params">
<tt class="descname">mimetype_params</tt><a class="headerlink" href="#flask.Request.mimetype_params" title="Permalink to this definition">¶</a></dt>
<dd><p>The mimetype parameters as dict.  For example if the content
type is <tt class="docutils literal"><span class="pre">text/html;</span> <span class="pre">charset=utf-8</span></tt> the params would be
<tt class="docutils literal"><span class="pre">{'charset':</span> <span class="pre">'utf-8'}</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.module">
<tt class="descname">module</tt><a class="headerlink" href="#flask.Request.module" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the current module</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.parameter_storage_class">
<tt class="descname">parameter_storage_class</tt><a class="headerlink" href="#flask.Request.parameter_storage_class" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">ImmutableMultiDict</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.path">
<tt class="descname">path</tt><a class="headerlink" href="#flask.Request.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Requested path as unicode.  This works a bit like the regular path
info in the WSGI environment but will always include a leading slash,
even if the URL root is accessed.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.pragma">
<tt class="descname">pragma</tt><a class="headerlink" href="#flask.Request.pragma" title="Permalink to this definition">¶</a></dt>
<dd><p>The Pragma general-header field is used to include
implementation-specific directives that might apply to any recipient
along the request/response chain.  All pragma directives specify
optional behavior from the viewpoint of the protocol; however, some
systems MAY require that behavior be consistent with the directives.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.query_string">
<tt class="descname">query_string</tt><a class="headerlink" href="#flask.Request.query_string" title="Permalink to this definition">¶</a></dt>
<dd><p>The URL parameters as raw bytestring.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.referrer">
<tt class="descname">referrer</tt><a class="headerlink" href="#flask.Request.referrer" title="Permalink to this definition">¶</a></dt>
<dd><p>The Referer[sic] request-header field allows the client to specify,
for the server&#8217;s benefit, the address (URI) of the resource from which
the Request-URI was obtained (the &#8220;referrer&#8221;, although the header
field is misspelled).</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.remote_addr">
<tt class="descname">remote_addr</tt><a class="headerlink" href="#flask.Request.remote_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>The remote address of the client.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.remote_user">
<tt class="descname">remote_user</tt><a class="headerlink" href="#flask.Request.remote_user" title="Permalink to this definition">¶</a></dt>
<dd><p>If the server supports user authentication, and the script is
protected, this attribute contains the username the user has
authenticated as.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.routing_exception">
<tt class="descname">routing_exception</tt><a class="headerlink" href="#flask.Request.routing_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>if matching the URL failed, this is the exception that will be
raised / was raised as part of the request handling.  This is
usually a <a class="reference internal" href="werkzeug.html#werkzeug.exceptions.NotFound" title="werkzeug.exceptions.NotFound"><tt class="xref py py-exc docutils literal"><span class="pre">NotFound</span></tt></a> exception or
something similar.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.script_root">
<tt class="descname">script_root</tt><a class="headerlink" href="#flask.Request.script_root" title="Permalink to this definition">¶</a></dt>
<dd><p>The root path of the script without the trailing slash.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.stream">
<tt class="descname">stream</tt><a class="headerlink" href="#flask.Request.stream" title="Permalink to this definition">¶</a></dt>
<dd><p>The parsed stream if the submitted data was not multipart or
urlencoded form data.  This stream is the stream left by the form data
parser module after parsing.  This is <em>not</em> the WSGI input stream but
a wrapper around it that ensures the caller does not accidentally
read past <cite>Content-Length</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.url">
<tt class="descname">url</tt><a class="headerlink" href="#flask.Request.url" title="Permalink to this definition">¶</a></dt>
<dd><p>The reconstructed current URL</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.url_charset">
<tt class="descname">url_charset</tt><a class="headerlink" href="#flask.Request.url_charset" title="Permalink to this definition">¶</a></dt>
<dd><p>The charset that is assumed for URLs.  Defaults to the value
of <tt class="xref py py-attr docutils literal"><span class="pre">charset</span></tt>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.url_root">
<tt class="descname">url_root</tt><a class="headerlink" href="#flask.Request.url_root" title="Permalink to this definition">¶</a></dt>
<dd><p>The full URL root (with hostname), this is the application root.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.url_rule">
<tt class="descname">url_rule</tt><a class="headerlink" href="#flask.Request.url_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>the internal URL rule that matched the request.  This can be
useful to inspect which methods are allowed for the URL from
a before/after handler (<tt class="docutils literal"><span class="pre">request.url_rule.methods</span></tt>) etc.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.user_agent">
<tt class="descname">user_agent</tt><a class="headerlink" href="#flask.Request.user_agent" title="Permalink to this definition">¶</a></dt>
<dd><p>The current user agent.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.values">
<tt class="descname">values</tt><a class="headerlink" href="#flask.Request.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Combined multi dict for <a class="reference internal" href="#flask.Request.args" title="flask.Request.args"><tt class="xref py py-attr docutils literal"><span class="pre">args</span></tt></a> and <a class="reference internal" href="#flask.Request.form" title="flask.Request.form"><tt class="xref py py-attr docutils literal"><span class="pre">form</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Request.view_args">
<tt class="descname">view_args</tt><a class="headerlink" href="#flask.Request.view_args" title="Permalink to this definition">¶</a></dt>
<dd><p>a dict of view arguments that matched the request.  If an exception
happened when matching, this will be <cite>None</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="flask.Response">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Response</tt><big>(</big><em>response=None</em>, <em>status=None</em>, <em>headers=None</em>, <em>mimetype=None</em>, <em>content_type=None</em>, <em>direct_passthrough=False</em><big>)</big><a class="headerlink" href="#flask.Response" title="Permalink to this definition">¶</a></dt>
<dd><p>The response object that is used by default in flask.  Works like the
response object from Werkzeug but is set to have a HTML mimetype by
default.  Quite often you don&#8217;t have to create this object yourself because
<a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">make_response()</span></tt></a> will take care of that for you.</p>
<p>If you want to replace the response object used you can subclass this and
set <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> to your subclass.</p>
<dl class="method">
<dt id="flask.Response.add_etag">
<tt class="descname">add_etag</tt><big>(</big><em>overwrite=False</em>, <em>weak=False</em><big>)</big><a class="headerlink" href="#flask.Response.add_etag" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an etag for the current response if there is none yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.age">
<tt class="descname">age</tt><a class="headerlink" href="#flask.Response.age" title="Permalink to this definition">¶</a></dt>
<dd><p>The Age response-header field conveys the sender&#8217;s estimate of the
amount of time since the response (or its revalidation) was
generated at the origin server.</p>
<p>Age values are non-negative decimal integers, representing time in
seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.allow">
<tt class="descname">allow</tt><a class="headerlink" href="#flask.Response.allow" title="Permalink to this definition">¶</a></dt>
<dd><p>The Allow entity-header field lists the set of methods supported
by the resource identified by the Request-URI. The purpose of this
field is strictly to inform the recipient of valid methods
associated with the resource. An Allow header field MUST be
present in a 405 (Method Not Allowed) response.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.cache_control">
<tt class="descname">cache_control</tt><a class="headerlink" href="#flask.Response.cache_control" title="Permalink to this definition">¶</a></dt>
<dd><p>The Cache-Control general-header field is used to specify
directives that MUST be obeyed by all caching mechanisms along the
request/response chain.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.call_on_close">
<tt class="descname">call_on_close</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#flask.Response.call_on_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a function to the internal list of functions that should
be called as part of closing down the response.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Response.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the wrapped response if possible.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.content_encoding">
<tt class="descname">content_encoding</tt><a class="headerlink" href="#flask.Response.content_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Encoding entity-header field is used as a modifier to the
media-type.  When present, its value indicates what additional content
codings have been applied to the entity-body, and thus what decoding
mechanisms must be applied in order to obtain the media-type
referenced by the Content-Type header field.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.content_language">
<tt class="descname">content_language</tt><a class="headerlink" href="#flask.Response.content_language" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Language entity-header field describes the natural
language(s) of the intended audience for the enclosed entity.  Note
that this might not be equivalent to all the languages used within
the entity-body.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.content_length">
<tt class="descname">content_length</tt><a class="headerlink" href="#flask.Response.content_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Length entity-header field indicates the size of the
entity-body, in decimal number of OCTETs, sent to the recipient or,
in the case of the HEAD method, the size of the entity-body that would
have been sent had the request been a GET.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.content_location">
<tt class="descname">content_location</tt><a class="headerlink" href="#flask.Response.content_location" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Location entity-header field MAY be used to supply the
resource location for the entity enclosed in the message when that
entity is accessible from a location separate from the requested
resource&#8217;s URI.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.content_md5">
<tt class="descname">content_md5</tt><a class="headerlink" href="#flask.Response.content_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-MD5 entity-header field, as defined in RFC 1864, is an
MD5 digest of the entity-body for the purpose of providing an
end-to-end message integrity check (MIC) of the entity-body.  (Note:
a MIC is good for detecting accidental modification of the
entity-body in transit, but is not proof against malicious attacks.)</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.content_type">
<tt class="descname">content_type</tt><a class="headerlink" href="#flask.Response.content_type" title="Permalink to this definition">¶</a></dt>
<dd><p>The Content-Type entity-header field indicates the media type of the
entity-body sent to the recipient or, in the case of the HEAD method,
the media type that would have been sent had the request been a GET.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.data">
<tt class="descname">data</tt><a class="headerlink" href="#flask.Response.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The string representation of the request body.  Whenever you access
this property the request iterable is encoded and flattened.  This
can lead to unwanted behavior if you stream big data.</p>
<p>This behavior can be disabled by setting
<tt class="xref py py-attr docutils literal"><span class="pre">implicit_sequence_conversion</span></tt> to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.date">
<tt class="descname">date</tt><a class="headerlink" href="#flask.Response.date" title="Permalink to this definition">¶</a></dt>
<dd><p>The Date general-header field represents the date and time at which
the message was originated, having the same semantics as orig-date
in RFC 822.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.delete_cookie">
<tt class="descname">delete_cookie</tt><big>(</big><em>key</em>, <em>path='/'</em>, <em>domain=None</em><big>)</big><a class="headerlink" href="#flask.Response.delete_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a cookie.  Fails silently if key doesn&#8217;t exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; the key (name) of the cookie to be deleted.</li>
<li><strong>path</strong> &#8211; if the cookie that should be deleted was limited to a
path, the path has to be defined here.</li>
<li><strong>domain</strong> &#8211; if the cookie that should be deleted was limited to a
domain, that domain has to be defined here.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.expires">
<tt class="descname">expires</tt><a class="headerlink" href="#flask.Response.expires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Expires entity-header field gives the date/time after which the
response is considered stale. A stale cache entry may not normally be
returned by a cache.</p>
</dd></dl>

<dl class="classmethod">
<dt id="flask.Response.force_type">
<em class="property">classmethod </em><tt class="descname">force_type</tt><big>(</big><em>response</em>, <em>environ=None</em><big>)</big><a class="headerlink" href="#flask.Response.force_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Enforce that the WSGI response is a response object of the current
type.  Werkzeug will use the <tt class="xref py py-class docutils literal"><span class="pre">BaseResponse</span></tt> internally in many
situations like the exceptions.  If you call <tt class="xref py py-meth docutils literal"><span class="pre">get_response()</span></tt> on an
exception you will get back a regular <tt class="xref py py-class docutils literal"><span class="pre">BaseResponse</span></tt> object, even
if you are using a custom subclass.</p>
<p>This method can enforce a given response type, and it will also
convert arbitrary WSGI callables into response objects if an environ
is provided:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># convert a Werkzeug response object into an instance of the</span>
<span class="c"># MyResponseClass subclass.</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">MyResponseClass</span><span class="o">.</span><span class="n">force_type</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

<span class="c"># convert any WSGI application into a response object</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">MyResponseClass</span><span class="o">.</span><span class="n">force_type</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">environ</span><span class="p">)</span>
</pre></div>
</div>
<p>This is especially useful if you want to post-process responses in
the main dispatcher and use functionality provided by your subclass.</p>
<p>Keep in mind that this will modify response objects in place if
possible!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>response</strong> &#8211; a response object or wsgi application.</li>
<li><strong>environ</strong> &#8211; a WSGI environment object.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a response object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Response.freeze">
<tt class="descname">freeze</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Response.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method if you want to make your response object ready for
being pickled.  This buffers the generator if there is one.  It will
also set the <cite>Content-Length</cite> header to the length of the body.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.6: </span>The <cite>Content-Length</cite> header is now set.</p>
</dd></dl>

<dl class="classmethod">
<dt id="flask.Response.from_app">
<em class="property">classmethod </em><tt class="descname">from_app</tt><big>(</big><em>app</em>, <em>environ</em>, <em>buffered=False</em><big>)</big><a class="headerlink" href="#flask.Response.from_app" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new response object from an application output.  This
works best if you pass it an application that returns a generator all
the time.  Sometimes applications may use the <cite>write()</cite> callable
returned by the <cite>start_response</cite> function.  This tries to resolve such
edge cases automatically.  But if you don&#8217;t get the expected output
you should set <cite>buffered</cite> to <cite>True</cite> which enforces buffering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>app</strong> &#8211; the WSGI application to execute.</li>
<li><strong>environ</strong> &#8211; the WSGI environment to execute against.</li>
<li><strong>buffered</strong> &#8211; set to <cite>True</cite> to enforce buffering.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a response object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Response.get_app_iter">
<tt class="descname">get_app_iter</tt><big>(</big><em>environ</em><big>)</big><a class="headerlink" href="#flask.Response.get_app_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the application iterator for the given environ.  Depending
on the request method and the current status code the return value
might be an empty response rather than the one from the response.</p>
<p>If the request method is <cite>HEAD</cite> or the status code is in a range
where the HTTP specification requires an empty response, an empty
iterable is returned.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>environ</strong> &#8211; the WSGI environment of the request.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a response iterable.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Response.get_etag">
<tt class="descname">get_etag</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Response.get_etag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple in the form <tt class="docutils literal"><span class="pre">(etag,</span> <span class="pre">is_weak)</span></tt>.  If there is no
ETag the return value is <tt class="docutils literal"><span class="pre">(None,</span> <span class="pre">None)</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.get_wsgi_headers">
<tt class="descname">get_wsgi_headers</tt><big>(</big><em>environ</em><big>)</big><a class="headerlink" href="#flask.Response.get_wsgi_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>This is automatically called right before the response is started
and returns headers modified for the given environment.  It returns a
copy of the headers from the response with some modifications applied
if necessary.</p>
<p>For example the location header (if present) is joined with the root
URL of the environment.  Also the content length is automatically set
to zero here for certain status codes.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.6: </span>Previously that function was called <cite>fix_headers</cite> and modified
the response object in place.  Also since 0.6, IRIs in location
and content-location headers are handled properly.<p>Also starting with 0.6, Werkzeug will attempt to set the content
length if it is able to figure it out on its own.  This is the
case if all the strings in the response iterable are already
encoded and the iterable is buffered.</p>
</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>environ</strong> &#8211; the WSGI environment of the request.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">returns a new <tt class="xref py py-class docutils literal"><span class="pre">Headers</span></tt> object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Response.get_wsgi_response">
<tt class="descname">get_wsgi_response</tt><big>(</big><em>environ</em><big>)</big><a class="headerlink" href="#flask.Response.get_wsgi_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the final WSGI response as tuple.  The first item in
the tuple is the application iterator, the second the status and
the third the list of headers.  The response returned is created
specially for the given environment.  For example if the request
method in the WSGI environment is <tt class="docutils literal"><span class="pre">'HEAD'</span></tt> the response will
be empty and only the headers and status code will be present.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>environ</strong> &#8211; the WSGI environment of the request.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <tt class="docutils literal"><span class="pre">(app_iter,</span> <span class="pre">status,</span> <span class="pre">headers)</span></tt> tuple.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.is_sequence">
<tt class="descname">is_sequence</tt><a class="headerlink" href="#flask.Response.is_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>If the iterator is buffered, this property will be <cite>True</cite>.  A
response object will consider an iterator to be buffered if the
response attribute is a list or tuple.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.is_streamed">
<tt class="descname">is_streamed</tt><a class="headerlink" href="#flask.Response.is_streamed" title="Permalink to this definition">¶</a></dt>
<dd><p>If the response is streamed (the response is not an iterable with
a length information) this property is <cite>True</cite>.  In this case streamed
means that there is no information about the number of iterations.
This is usually <cite>True</cite> if a generator is passed to the response object.</p>
<p>This is useful for checking before applying some sort of post
filtering that should not take place for streamed responses.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.iter_encoded">
<tt class="descname">iter_encoded</tt><big>(</big><em>charset=None</em><big>)</big><a class="headerlink" href="#flask.Response.iter_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>Iter the response encoded with the encoding of the response.
If the response object is invoked as WSGI application the return
value of this method is used as application iterator unless
<tt class="xref py py-attr docutils literal"><span class="pre">direct_passthrough</span></tt> was activated.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.6.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.last_modified">
<tt class="descname">last_modified</tt><a class="headerlink" href="#flask.Response.last_modified" title="Permalink to this definition">¶</a></dt>
<dd><p>The Last-Modified entity-header field indicates the date and time at
which the origin server believes the variant was last modified.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.location">
<tt class="descname">location</tt><a class="headerlink" href="#flask.Response.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The Location response-header field is used to redirect the recipient
to a location other than the Request-URI for completion of the request
or identification of a new resource.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.make_conditional">
<tt class="descname">make_conditional</tt><big>(</big><em>request_or_environ</em><big>)</big><a class="headerlink" href="#flask.Response.make_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the response conditional to the request.  This method works
best if an etag was defined for the response already.  The <cite>add_etag</cite>
method can be used to do that.  If called without etag just the date
header is set.</p>
<p>This does nothing if the request method in the request or environ is
anything but GET or HEAD.</p>
<p>It does not remove the body of the response because that&#8217;s something
the <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> function does for us automatically.</p>
<p>Returns self so that you can do <tt class="docutils literal"><span class="pre">return</span> <span class="pre">resp.make_conditional(req)</span></tt>
but modifies the object in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>request_or_environ</strong> &#8211; a request object or WSGI environment to be
used to make the response conditional
against.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Response.make_sequence">
<tt class="descname">make_sequence</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Response.make_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the response iterator in a list.  By default this happens
automatically if required.  If <cite>implicit_sequence_conversion</cite> is
disabled, this method is not automatically called and some properties
might raise exceptions.  This also encodes all the items.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.mimetype">
<tt class="descname">mimetype</tt><a class="headerlink" href="#flask.Response.mimetype" title="Permalink to this definition">¶</a></dt>
<dd><p>The mimetype (content type without charset etc.)</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.mimetype_params">
<tt class="descname">mimetype_params</tt><a class="headerlink" href="#flask.Response.mimetype_params" title="Permalink to this definition">¶</a></dt>
<dd><p>The mimetype parameters as dict.  For example if the content
type is <tt class="docutils literal"><span class="pre">text/html;</span> <span class="pre">charset=utf-8</span></tt> the params would be
<tt class="docutils literal"><span class="pre">{'charset':</span> <span class="pre">'utf-8'}</span></tt>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.retry_after">
<tt class="descname">retry_after</tt><a class="headerlink" href="#flask.Response.retry_after" title="Permalink to this definition">¶</a></dt>
<dd><p>The Retry-After response-header field can be used with a 503 (Service
Unavailable) response to indicate how long the service is expected
to be unavailable to the requesting client.</p>
<p>Time in seconds until expiration or date.</p>
</dd></dl>

<dl class="method">
<dt id="flask.Response.set_cookie">
<tt class="descname">set_cookie</tt><big>(</big><em>key</em>, <em>value=''</em>, <em>max_age=None</em>, <em>expires=None</em>, <em>path='/'</em>, <em>domain=None</em>, <em>secure=None</em>, <em>httponly=False</em><big>)</big><a class="headerlink" href="#flask.Response.set_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a cookie. The parameters are the same as in the cookie <cite>Morsel</cite>
object in the Python standard library but it accepts unicode data, too.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; the key (name) of the cookie to be set.</li>
<li><strong>value</strong> &#8211; the value of the cookie.</li>
<li><strong>max_age</strong> &#8211; should be a number of seconds, or <cite>None</cite> (default) if
the cookie should last only as long as the client&#8217;s
browser session.</li>
<li><strong>expires</strong> &#8211; should be a <cite>datetime</cite> object or UNIX timestamp.</li>
<li><strong>domain</strong> &#8211; if you want to set a cross-domain cookie.  For example,
<tt class="docutils literal"><span class="pre">domain=&quot;.example.com&quot;</span></tt> will set a cookie that is
readable by the domain <tt class="docutils literal"><span class="pre">www.example.com</span></tt>,
<tt class="docutils literal"><span class="pre">foo.example.com</span></tt> etc.  Otherwise, a cookie will only
be readable by the domain that set it.</li>
<li><strong>path</strong> &#8211; limits the cookie to a given path, per default it will
span the whole domain.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Response.set_etag">
<tt class="descname">set_etag</tt><big>(</big><em>etag</em>, <em>weak=False</em><big>)</big><a class="headerlink" href="#flask.Response.set_etag" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the etag, and override the old one if there was one.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.stream">
<tt class="descname">stream</tt><a class="headerlink" href="#flask.Response.stream" title="Permalink to this definition">¶</a></dt>
<dd><p>The response iterable as write-only stream.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.vary">
<tt class="descname">vary</tt><a class="headerlink" href="#flask.Response.vary" title="Permalink to this definition">¶</a></dt>
<dd><p>The Vary field value indicates the set of request-header fields that
fully determines, while the response is fresh, whether a cache is
permitted to use the response to reply to a subsequent request
without revalidation.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.www_authenticate">
<tt class="descname">www_authenticate</tt><a class="headerlink" href="#flask.Response.www_authenticate" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>WWW-Authenticate</cite> header in a parsed form.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="flask.url_for">
<tt class="descclassname">flask.</tt><tt class="descname">url_for</tt><big>(</big><em>endpoint</em>, <em>**values</em><big>)</big><a class="headerlink" href="#flask.url_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a URL to the given endpoint with the method provided.
The endpoint is relative to the active module if modules are in use.</p>
<p>Here some examples:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="32%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Active Module</th>
<th class="head">Target Endpoint</th>
<th class="head">Target Function</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><cite>None</cite></td>
<td><tt class="docutils literal"><span class="pre">'index'</span></tt></td>
<td><cite>index</cite> of the application</td>
</tr>
<tr><td><cite>None</cite></td>
<td><tt class="docutils literal"><span class="pre">'.index'</span></tt></td>
<td><cite>index</cite> of the application</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'admin'</span></tt></td>
<td><tt class="docutils literal"><span class="pre">'index'</span></tt></td>
<td><cite>index</cite> of the <cite>admin</cite> module</td>
</tr>
<tr><td>any</td>
<td><tt class="docutils literal"><span class="pre">'.index'</span></tt></td>
<td><cite>index</cite> of the application</td>
</tr>
<tr><td>any</td>
<td><tt class="docutils literal"><span class="pre">'admin.index'</span></tt></td>
<td><cite>index</cite> of the <cite>admin</cite> module</td>
</tr>
</tbody>
</table>
<p>Variable arguments that are unknown to the target endpoint are appended
to the generated URL as query arguments.</p>
<p>For more information, head over to the <a class="reference external" href="http://flask.pocoo.org/docs/quickstart/#url-building" title="(in Flask v0.6)"><em class="xref std std-ref">Quickstart</em></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>endpoint</strong> &#8211; the endpoint of the URL (name of the function)</li>
<li><strong>values</strong> &#8211; the variable arguments of the URL rule</li>
<li><strong>_external</strong> &#8211; if set to <cite>True</cite>, an absolute URL is generated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.abort">
<tt class="descclassname">flask.</tt><tt class="descname">abort</tt><big>(</big><em>mapping=None</em>, <em>extra=None</em><big>)</big><a class="headerlink" href="#flask.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>When passed a dict of code -&gt; exception items it can be used as
callable that raises exceptions.  If the first argument to the
callable is an integer it will be looked up in the mapping, if it&#8217;s
a WSGI application it will be raised in a proxy exception.</p>
<p>The rest of the arguments are forwarded to the exception constructor.</p>
</dd></dl>

<dl class="function">
<dt id="flask.redirect">
<tt class="descclassname">flask.</tt><tt class="descname">redirect</tt><big>(</big><em>location</em>, <em>code=302</em><big>)</big><a class="headerlink" href="#flask.redirect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a response object (a WSGI application) that, if called,
redirects the client to the target location.  Supported codes are 301,
302, 303, 305, and 307.  300 is not supported because it&#8217;s not a real
redirect and 304 because it&#8217;s the answer for a request with a request
with defined If-Modified-Since headers.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6: </span>The location can now be a unicode string that is encoded using
the <tt class="xref py py-func docutils literal"><span class="pre">iri_to_uri()</span></tt> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>location</strong> &#8211; the location the response should redirect to.</li>
<li><strong>code</strong> &#8211; the redirect status code.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.send_file">
<tt class="descclassname">flask.</tt><tt class="descname">send_file</tt><big>(</big><em>filename_or_fp</em>, <em>mimetype=None</em>, <em>as_attachment=False</em>, <em>attachment_filename=None</em>, <em>add_etags=True</em>, <em>cache_timeout=43200</em>, <em>conditional=False</em><big>)</big><a class="headerlink" href="#flask.send_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends the contents of a file to the client.  This will use the
most efficient method available and configured.  By default it will
try to use the WSGI server&#8217;s file_wrapper support.  Alternatively
you can set the application&#8217;s <a class="reference internal" href="#flask.Flask.use_x_sendfile" title="flask.Flask.use_x_sendfile"><tt class="xref py py-attr docutils literal"><span class="pre">use_x_sendfile</span></tt></a> attribute
to <tt class="xref docutils literal"><span class="pre">True</span></tt> to directly emit an <cite>X-Sendfile</cite> header.  This however
requires support of the underlying webserver for <cite>X-Sendfile</cite>.</p>
<p>By default it will try to guess the mimetype for you, but you can
also explicitly provide one.  For extra security you probably want
to sent certain files as attachment (HTML for instance).</p>
<p>Please never pass filenames to this function from user sources without
checking them first.  Something like this is usually sufficient to
avoid security problems:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="s">&#39;..&#39;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">):</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
<p class="versionadded">
<span class="versionmodified">New in version 0.5: </span>The <cite>add_etags</cite>, <cite>cache_timeout</cite> and <cite>conditional</cite> parameters were
added.  The default behaviour is now to attach etags.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename_or_fp</strong> &#8211; the filename of the file to send.  This is
relative to the <tt class="xref py py-attr docutils literal"><span class="pre">root_path</span></tt> if a
relative path is specified.
Alternatively a file object might be provided
in which case <cite>X-Sendfile</cite> might not work and
fall back to the traditional method.</li>
<li><strong>mimetype</strong> &#8211; the mimetype of the file if provided, otherwise
auto detection happens.</li>
<li><strong>as_attachment</strong> &#8211; set to <cite>True</cite> if you want to send this file with
a <tt class="docutils literal"><span class="pre">Content-Disposition:</span> <span class="pre">attachment</span></tt> header.</li>
<li><strong>attachment_filename</strong> &#8211; the filename for the attachment if it
differs from the file&#8217;s filename.</li>
<li><strong>add_etags</strong> &#8211; set to <cite>False</cite> to disable attaching of etags.</li>
<li><strong>conditional</strong> &#8211; set to <cite>True</cite> to enable conditional responses.</li>
<li><strong>cache_timeout</strong> &#8211; the timeout in seconds for the headers.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.send_from_directory">
<tt class="descclassname">flask.</tt><tt class="descname">send_from_directory</tt><big>(</big><em>directory</em>, <em>filename</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.send_from_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a file from a given directory with <a class="reference internal" href="#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>.  This
is a secure way to quickly expose static files from an upload folder
or something similar.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/uploads/&lt;path:filename&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">download_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">send_from_directory</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s">&#39;UPLOAD_FOLDER&#39;</span><span class="p">],</span>
                               <span class="n">filename</span><span class="p">,</span> <span class="n">as_attachment</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-sending-files-and-performance admonition ">
<p class="first admonition-title">Sending files and Performance</p>
<p class="last">It is strongly recommended to activate either <cite>X-Sendfile</cite> support in
your webserver or (if no authentication happens) to tell the webserver
to serve files for the given path on its own without calling into the
web application for improved performance.</p>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.5.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>directory</strong> &#8211; the directory where all the files are stored.</li>
<li><strong>filename</strong> &#8211; the filename relative to that directory to
download.</li>
<li><strong>options</strong> &#8211; optional keyword arguments that are directly
forwarded to <a class="reference internal" href="#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.flash">
<tt class="descclassname">flask.</tt><tt class="descname">flash</tt><big>(</big><em>message</em>, <em>category='message'</em><big>)</big><a class="headerlink" href="#flask.flash" title="Permalink to this definition">¶</a></dt>
<dd><p>Flashes a message to the next request.  In order to remove the
flashed message from the session and to display it to the user,
the template has to call <a class="reference internal" href="#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>message</strong> &#8211; the message to be flashed.</li>
<li><strong>category</strong> &#8211; the category for the message.  The following values
are recommended: <tt class="docutils literal"><span class="pre">'message'</span></tt> for any kind of message,
<tt class="docutils literal"><span class="pre">'error'</span></tt> for errors, <tt class="docutils literal"><span class="pre">'info'</span></tt> for information
messages and <tt class="docutils literal"><span class="pre">'warning'</span></tt> for warnings.  However any
kind of string can be used as category.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.get_flashed_messages">
<tt class="descclassname">flask.</tt><tt class="descname">get_flashed_messages</tt><big>(</big><em>with_categories=False</em><big>)</big><a class="headerlink" href="#flask.get_flashed_messages" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls all flashed messages from the session and returns them.
Further calls in the same request to the function will return
the same messages.  By default just the messages are returned,
but when <cite>with_categories</cite> is set to <cite>True</cite>, the return value will
be a list of tuples in the form <tt class="docutils literal"><span class="pre">(category,</span> <span class="pre">message)</span></tt> instead.</p>
<p>Example usage:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">for</span> <span class="nv">category</span><span class="o">,</span> <span class="nv">msg</span> <span class="k">in</span> <span class="nv">get_flashed_messages</span><span class="o">(</span><span class="nv">with_categories</span><span class="o">=</span><span class="kp">true</span><span class="o">)</span> <span class="cp">%}</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">flash-</span><span class="cp">{{</span> <span class="nv">category</span> <span class="cp">}}</span><span class="nt">&gt;</span><span class="cp">{{</span> <span class="nv">msg</span> <span class="cp">}}</span>
<span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.3: </span><cite>with_categories</cite> parameter added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>with_categories</strong> &#8211; set to <cite>True</cite> to also receive categories.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.jsonify">
<tt class="descclassname">flask.</tt><tt class="descname">jsonify</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.jsonify" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> with the JSON representation of
the given arguments with an <cite>application/json</cite> mimetype.  The arguments
to this function are the same as to the <a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> constructor.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/_get_current_user&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_current_user</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
                   <span class="n">email</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span>
                   <span class="nb">id</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<p>This will send a JSON response like this to the browser:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
    <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;admin&quot;</span><span class="p">,</span>
    <span class="s">&quot;email&quot;</span><span class="p">:</span> <span class="s">&quot;admin@localhost&quot;</span><span class="p">,</span>
    <span class="s">&quot;id&quot;</span><span class="p">:</span> <span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This requires Python 2.6 or an installed version of simplejson.  For
security reasons only objects are supported toplevel.  For more
information about this, have a look at <a class="reference external" href="http://flask.pocoo.org/docs/security/#json-security" title="(in Flask v0.6)"><em>JSON Security</em></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Flask microframework</a><ul>
<li><a class="reference internal" href="#application">Application</a></li>
<li><a class="reference internal" href="#request-and-response">Request and Response</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="hacking.html" title="previous chapter">Hacking on stutuz</a></li>
      <li>Next: <a href="werkzeug.html" title="next chapter">Werkzeug WSGI utilities</a></li>
  </ul></li>
</ul>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/flask.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Dag Odenhall.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>